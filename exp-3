import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix, roc_curve, auc, precision_recall_curve, classification_report

class ClassificationEvaluator:
    def __init__(self, y_true, y_pred, y_prob=None, labels=None, name="Model"):
        self.y_true, self.y_pred, self.y_prob = np.array(y_true), np.array(y_pred), y_prob
        self.labels, self.name = labels, name
        self.cm = confusion_matrix(y_true, y_pred)
        self.is_binary = len(np.unique(y_true)) == 2

    def get_metrics(self):
        rep = classification_report(self.y_true, self.y_pred, output_dict=True)
        m = {"Accuracy": rep['accuracy'], "Macro_F1": rep['macro avg']['f1-score']}
        if self.is_binary:
            tn, fp, fn, tp = self.cm.ravel()
            m.update({"Precision": tp/(tp+fp), "Recall": tp/(tp+fn), "Specificity": tn/(tn+fp)})
            if self.y_prob is not None:
                fpr, tpr, _ = roc_curve(self.y_true, self.y_prob)
                m["AUC_ROC"] = auc(fpr, tpr)
        return m

    def plot_all(self):
        fig, axes = plt.subplots(1, 3 if self.y_prob is not None else 1, figsize=(18, 5))
        if self.y_prob is None: axes = [axes]
        
        sns.heatmap(self.cm, annot=True, fmt='d', cmap='Blues', ax=axes[0],
                    xticklabels=self.labels, yticklabels=self.labels)
        axes[0].set_title(f"Confusion Matrix: {self.name}")
        
        if self.y_prob is not None and self.is_binary:
            fpr, tpr, _ = roc_curve(self.y_true, self.y_prob)
            axes[1].plot(fpr, tpr, label=f"AUC: {auc(fpr, tpr):.3f}")
            axes[1].plot([0, 1], [0, 1], 'k--')
            axes[1].set_title("ROC Curve")
            axes[1].legend()

            prec, rec, _ = precision_recall_curve(self.y_true, self.y_prob)
            axes[2].plot(rec, prec, color='green')
            axes[2].set_title("Precision-Recall Curve")
        
        plt.tight_layout()
        plt.show()

if __name__ == "__main__":
    np.random.seed(42)
    y_t = np.random.choice([0, 1], size=100)
    y_p = np.random.choice([0, 1], size=100, p=[0.6, 0.4])
    y_s = np.random.uniform(0, 1, 100)
    
    evaluator = ClassificationEvaluator(y_t, y_p, y_s, labels=['Negative', 'Positive'])
    print(pd.Series(evaluator.get_metrics()))
    evaluator.plot_all()
